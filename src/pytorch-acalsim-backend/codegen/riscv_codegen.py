# Copyright 2023-2025 Playlab/ACAL
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""RISC-V bare-metal code generator for ACALSim IR.

This module generates C code that runs on the QEMU-SST simulator,
communicating with SST components via MMIO.
"""

import os
from typing import Dict, List, Optional, Tuple
import numpy as np

from acalsim_backend.ir import ACALSimIR, ACALSimOp, ACALSimOpType, TensorDesc


# Device memory map (from qemu-acalsim-sst-baremetal)
ECHO_DEVICE_BASE = 0x10200000
COMPUTE_DEVICE_BASE = 0x10300000

# Compute device register offsets
REG_CMD = 0x00  # Command register
REG_STATUS = 0x04  # Status register
REG_DATA_IN = 0x08  # Data input register
REG_DATA_OUT = 0x0C  # Data output register
REG_SIZE = 0x10  # Data size register
REG_RESULT = 0x14  # Result register

# Command values
CMD_NOP = 0
CMD_LOAD = 1
CMD_STORE = 2
CMD_COMPUTE = 3
CMD_MATMUL = 4
CMD_CONV2D = 5


class RISCVCodeGenerator:
    """Generates RISC-V bare-metal C code from ACALSim IR.

    The generated code uses MMIO to communicate with SST accelerator
    components through the QEMU-SST bridge.
    """

    def __init__(self, output_dir: str = "."):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def generate(self, ir: ACALSimIR, name: str = "kernel") -> List[str]:
        """Generate RISC-V C code from ACALSim IR.

        Args:
            ir: The ACALSim IR to compile
            name: Base name for generated files

        Returns:
            List of generated file paths
        """
        generated_files = []

        # Generate main C file
        c_file = os.path.join(self.output_dir, f"{name}.c")
        with open(c_file, "w") as f:
            f.write(self._generate_c_source(ir, name))
        generated_files.append(c_file)

        # Generate header file with tensor definitions
        h_file = os.path.join(self.output_dir, f"{name}.h")
        with open(h_file, "w") as f:
            f.write(self._generate_header(ir, name))
        generated_files.append(h_file)

        # Generate weight data file (binary)
        if ir.constants:
            data_file = os.path.join(self.output_dir, f"{name}_weights.bin")
            self._generate_weight_data(ir, data_file)
            generated_files.append(data_file)

            # Also generate C array for weights
            weights_c = os.path.join(self.output_dir, f"{name}_weights.c")
            with open(weights_c, "w") as f:
                f.write(self._generate_weights_c(ir, name))
            generated_files.append(weights_c)

        # Generate Makefile
        makefile = os.path.join(self.output_dir, "Makefile")
        with open(makefile, "w") as f:
            f.write(self._generate_makefile(name))
        generated_files.append(makefile)

        # Generate linker script
        ld_file = os.path.join(self.output_dir, f"{name}.ld")
        with open(ld_file, "w") as f:
            f.write(self._generate_linker_script(ir))
        generated_files.append(ld_file)

        return generated_files

    def _generate_header(self, ir: ACALSimIR, name: str) -> str:
        """Generate header file with tensor definitions."""
        guard = f"{name.upper()}_H"
        lines = [
            f"// Auto-generated by ACALSim PyTorch Backend",
            f"// Graph: {ir.name}",
            f"#ifndef {guard}",
            f"#define {guard}",
            "",
            "#include <stdint.h>",
            "",
            "// Device base addresses",
            f"#define ECHO_DEVICE_BASE    0x{ECHO_DEVICE_BASE:08X}",
            f"#define COMPUTE_DEVICE_BASE 0x{COMPUTE_DEVICE_BASE:08X}",
            "",
            "// Compute device registers",
            f"#define REG_CMD      0x{REG_CMD:02X}",
            f"#define REG_STATUS   0x{REG_STATUS:02X}",
            f"#define REG_DATA_IN  0x{REG_DATA_IN:02X}",
            f"#define REG_DATA_OUT 0x{REG_DATA_OUT:02X}",
            f"#define REG_SIZE     0x{REG_SIZE:02X}",
            f"#define REG_RESULT   0x{REG_RESULT:02X}",
            "",
            "// Commands",
            f"#define CMD_NOP     {CMD_NOP}",
            f"#define CMD_LOAD    {CMD_LOAD}",
            f"#define CMD_STORE   {CMD_STORE}",
            f"#define CMD_COMPUTE {CMD_COMPUTE}",
            f"#define CMD_MATMUL  {CMD_MATMUL}",
            f"#define CMD_CONV2D  {CMD_CONV2D}",
            "",
            "// Tensor dimensions",
        ]

        # Add tensor dimension defines
        for tensor_name, tensor in ir.tensors.items():
            safe_name = self._safe_c_name(tensor_name)
            lines.append(f"#define {safe_name.upper()}_SIZE {tensor.numel}")
            for i, dim in enumerate(tensor.shape):
                lines.append(f"#define {safe_name.upper()}_DIM{i} {dim}")

        lines.extend([
            "",
            "// Function declarations",
            f"void {name}_init(void);",
            f"void {name}_forward(float* inputs, float* outputs);",
            f"void {name}_cleanup(void);",
            "",
            f"#endif // {guard}",
            "",
        ])

        return "\n".join(lines)

    def _generate_c_source(self, ir: ACALSimIR, name: str) -> str:
        """Generate main C source file."""
        lines = [
            "// Auto-generated by ACALSim PyTorch Backend",
            f"// Graph: {ir.name}",
            "",
            f'#include "{name}.h"',
            "#include <stddef.h>",
            "",
            "// MMIO helper macros",
            "#define MMIO_WRITE32(addr, val) (*(volatile uint32_t*)(addr) = (val))",
            "#define MMIO_READ32(addr) (*(volatile uint32_t*)(addr))",
            "#define MMIO_WRITE_FLOAT(addr, val) (*(volatile float*)(addr) = (val))",
            "#define MMIO_READ_FLOAT(addr) (*(volatile float*)(addr))",
            "",
            "// Wait for device to be ready",
            "static inline void wait_device_ready(void) {",
            "    while (MMIO_READ32(COMPUTE_DEVICE_BASE + REG_STATUS) != 0) {",
            "        // Busy wait",
            "    }",
            "}",
            "",
        ]

        # Declare tensor buffers
        lines.append("// Tensor buffers")
        for tensor_name, tensor in ir.tensors.items():
            if not tensor.is_param:  # Parameters come from weights file
                safe_name = self._safe_c_name(tensor_name)
                lines.append(
                    f"static float {safe_name}[{tensor.numel}];"
                )
        lines.append("")

        # External declaration for weights
        if ir.constants:
            lines.append("// External weight data")
            for const_name in ir.constants:
                safe_name = self._safe_c_name(const_name)
                lines.append(f"extern const float {safe_name}[];")
            lines.append("")

        # Generate init function
        lines.extend([
            f"void {name}_init(void) {{",
            "    // Initialize device",
            "    MMIO_WRITE32(COMPUTE_DEVICE_BASE + REG_CMD, CMD_NOP);",
            "    wait_device_ready();",
            "}",
            "",
        ])

        # Generate forward function
        lines.extend([
            f"void {name}_forward(float* inputs, float* outputs) {{",
        ])

        # Copy inputs to input tensors
        input_offset = 0
        for input_name in ir.input_names:
            tensor = ir.tensors.get(input_name)
            if tensor:
                safe_name = self._safe_c_name(input_name)
                lines.append(f"    // Copy input to {safe_name}")
                lines.append(f"    for (int i = 0; i < {tensor.numel}; i++) {{")
                lines.append(f"        {safe_name}[i] = inputs[{input_offset} + i];")
                lines.append("    }")
                input_offset += tensor.numel
        lines.append("")

        # Generate code for each operation
        for i, op in enumerate(ir.ops):
            lines.append(f"    // Op {i}: {op}")
            lines.extend(self._generate_op_code(op, ir))
            lines.append("")

        # Copy outputs
        output_offset = 0
        for output_name in ir.output_names:
            tensor = ir.tensors.get(output_name)
            if tensor:
                safe_name = self._safe_c_name(output_name)
                lines.append(f"    // Copy output from {safe_name}")
                lines.append(f"    for (int i = 0; i < {tensor.numel}; i++) {{")
                lines.append(f"        outputs[{output_offset} + i] = {safe_name}[i];")
                lines.append("    }")
                output_offset += tensor.numel

        lines.extend([
            "}",
            "",
        ])

        # Generate cleanup function
        lines.extend([
            f"void {name}_cleanup(void) {{",
            "    // Cleanup - nothing to do for static buffers",
            "}",
            "",
        ])

        # Generate main function
        lines.extend(self._generate_main_function(ir, name))

        return "\n".join(lines)

    def _generate_op_code(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate C code for a single operation."""
        lines = []

        # Get input/output tensor names
        inputs = [self._safe_c_name(n) for n in op.inputs]
        outputs = [self._safe_c_name(n) for n in op.outputs]

        if op.op_type == ACALSimOpType.ADD:
            lines.extend(self._gen_elementwise_op(op, ir, "+"))
        elif op.op_type == ACALSimOpType.SUB:
            lines.extend(self._gen_elementwise_op(op, ir, "-"))
        elif op.op_type == ACALSimOpType.MUL:
            lines.extend(self._gen_elementwise_op(op, ir, "*"))
        elif op.op_type == ACALSimOpType.DIV:
            lines.extend(self._gen_elementwise_op(op, ir, "/"))
        elif op.op_type == ACALSimOpType.RELU:
            lines.extend(self._gen_relu(op, ir))
        elif op.op_type == ACALSimOpType.SIGMOID:
            lines.extend(self._gen_sigmoid(op, ir))
        elif op.op_type == ACALSimOpType.TANH:
            lines.extend(self._gen_tanh(op, ir))
        elif op.op_type == ACALSimOpType.MATMUL:
            lines.extend(self._gen_matmul(op, ir))
        elif op.op_type == ACALSimOpType.GEMM:
            lines.extend(self._gen_gemm(op, ir))
        elif op.op_type == ACALSimOpType.SOFTMAX:
            lines.extend(self._gen_softmax(op, ir))
        elif op.op_type == ACALSimOpType.RESHAPE:
            lines.extend(self._gen_reshape(op, ir))
        else:
            # Fallback: just copy input to output
            if inputs and outputs:
                out_tensor = ir.tensors.get(op.outputs[0])
                if out_tensor:
                    lines.append(f"    // {op.op_type.name} - fallback copy")
                    lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
                    lines.append(f"        {outputs[0]}[i] = {inputs[0]}[i];")
                    lines.append("    }")

        return lines

    def _gen_elementwise_op(
        self, op: ACALSimOp, ir: ACALSimIR, operator: str
    ) -> List[str]:
        """Generate element-wise binary operation."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and len(op.inputs) >= 2:
            in0 = self._safe_c_name(op.inputs[0])
            in1 = self._safe_c_name(op.inputs[1])
            out = self._safe_c_name(op.outputs[0])
            lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
            lines.append(f"        {out}[i] = {in0}[i] {operator} {in1}[i];")
            lines.append("    }")
        return lines

    def _gen_relu(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate ReLU activation."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and op.inputs:
            inp = self._safe_c_name(op.inputs[0])
            out = self._safe_c_name(op.outputs[0])
            lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
            lines.append(f"        {out}[i] = {inp}[i] > 0 ? {inp}[i] : 0;")
            lines.append("    }")
        return lines

    def _gen_sigmoid(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate sigmoid activation (approximation)."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and op.inputs:
            inp = self._safe_c_name(op.inputs[0])
            out = self._safe_c_name(op.outputs[0])
            # Use piecewise linear approximation for bare-metal
            lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
            lines.append(f"        float x = {inp}[i];")
            lines.append("        if (x < -4.0f) {")
            lines.append(f"            {out}[i] = 0.0f;")
            lines.append("        } else if (x > 4.0f) {")
            lines.append(f"            {out}[i] = 1.0f;")
            lines.append("        } else {")
            lines.append(f"            {out}[i] = 0.5f + x * 0.125f;")
            lines.append("        }")
            lines.append("    }")
        return lines

    def _gen_tanh(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate tanh activation (approximation)."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and op.inputs:
            inp = self._safe_c_name(op.inputs[0])
            out = self._safe_c_name(op.outputs[0])
            # Use piecewise linear approximation
            lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
            lines.append(f"        float x = {inp}[i];")
            lines.append("        if (x < -3.0f) {")
            lines.append(f"            {out}[i] = -1.0f;")
            lines.append("        } else if (x > 3.0f) {")
            lines.append(f"            {out}[i] = 1.0f;")
            lines.append("        } else {")
            lines.append(f"            {out}[i] = x * (1.0f - x * x / 27.0f);")
            lines.append("        }")
            lines.append("    }")
        return lines

    def _gen_matmul(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate matrix multiplication."""
        lines = []
        if len(op.inputs) >= 2:
            a_name = op.inputs[0]
            b_name = op.inputs[1]
            out_name = op.outputs[0]

            a_tensor = ir.tensors.get(a_name)
            b_tensor = ir.tensors.get(b_name)
            out_tensor = ir.tensors.get(out_name)

            if a_tensor and b_tensor and out_tensor:
                # Assume 2D matrices for now
                a_safe = self._safe_c_name(a_name)
                b_safe = self._safe_c_name(b_name)
                out_safe = self._safe_c_name(out_name)

                M = a_tensor.shape[0] if len(a_tensor.shape) > 0 else 1
                K = a_tensor.shape[1] if len(a_tensor.shape) > 1 else 1
                N = b_tensor.shape[1] if len(b_tensor.shape) > 1 else 1

                lines.append(f"    // MATMUL: [{M}x{K}] @ [{K}x{N}] -> [{M}x{N}]")
                lines.append(f"    for (int m = 0; m < {M}; m++) {{")
                lines.append(f"        for (int n = 0; n < {N}; n++) {{")
                lines.append("            float sum = 0.0f;")
                lines.append(f"            for (int k = 0; k < {K}; k++) {{")
                lines.append(f"                sum += {a_safe}[m * {K} + k] * {b_safe}[k * {N} + n];")
                lines.append("            }")
                lines.append(f"            {out_safe}[m * {N} + n] = sum;")
                lines.append("        }")
                lines.append("    }")

        return lines

    def _gen_gemm(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate GEMM (Linear layer): Y = X @ W^T + b."""
        lines = []
        if len(op.inputs) >= 2:
            x_name = op.inputs[0]
            w_name = op.inputs[1]
            b_name = op.inputs[2] if len(op.inputs) > 2 else None
            out_name = op.outputs[0]

            x_tensor = ir.tensors.get(x_name)
            w_tensor = ir.tensors.get(w_name)
            out_tensor = ir.tensors.get(out_name)

            if x_tensor and w_tensor and out_tensor:
                x_safe = self._safe_c_name(x_name)
                w_safe = self._safe_c_name(w_name)
                out_safe = self._safe_c_name(out_name)

                # Get dimensions from attrs or tensors
                in_features = op.attrs.get("in_features", x_tensor.shape[-1] if x_tensor.shape else 1)
                out_features = op.attrs.get("out_features", w_tensor.shape[0] if w_tensor.shape else 1)

                # Batch size
                batch = x_tensor.numel // in_features if in_features > 0 else 1

                lines.append(f"    // GEMM: [{batch}x{in_features}] @ [{out_features}x{in_features}]^T -> [{batch}x{out_features}]")
                lines.append(f"    for (int b = 0; b < {batch}; b++) {{")
                lines.append(f"        for (int o = 0; o < {out_features}; o++) {{")
                lines.append("            float sum = 0.0f;")
                lines.append(f"            for (int i = 0; i < {in_features}; i++) {{")
                lines.append(f"                sum += {x_safe}[b * {in_features} + i] * {w_safe}[o * {in_features} + i];")
                lines.append("            }")

                if b_name:
                    b_safe = self._safe_c_name(b_name)
                    lines.append(f"            sum += {b_safe}[o];")

                lines.append(f"            {out_safe}[b * {out_features} + o] = sum;")
                lines.append("        }")
                lines.append("    }")

        return lines

    def _gen_softmax(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate softmax (simplified for last dim)."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and op.inputs:
            inp = self._safe_c_name(op.inputs[0])
            out = self._safe_c_name(op.outputs[0])

            lines.append("    // Softmax (simplified)")
            lines.append("    {")
            lines.append(f"        int n = {out_tensor.numel};")
            lines.append("        float max_val = -1e30f;")
            lines.append("        for (int i = 0; i < n; i++) {")
            lines.append(f"            if ({inp}[i] > max_val) max_val = {inp}[i];")
            lines.append("        }")
            lines.append("        float sum = 0.0f;")
            lines.append("        for (int i = 0; i < n; i++) {")
            lines.append(f"            float e = 1.0f;")
            lines.append(f"            float x = {inp}[i] - max_val;")
            lines.append("            // exp approximation: 1 + x + x^2/2 + x^3/6")
            lines.append("            e = 1.0f + x * (1.0f + x * (0.5f + x * 0.166667f));")
            lines.append("            if (e < 0) e = 0;")
            lines.append(f"            {out}[i] = e;")
            lines.append("            sum += e;")
            lines.append("        }")
            lines.append("        for (int i = 0; i < n; i++) {")
            lines.append(f"            {out}[i] /= sum;")
            lines.append("        }")
            lines.append("    }")

        return lines

    def _gen_reshape(self, op: ACALSimOp, ir: ACALSimIR) -> List[str]:
        """Generate reshape (just copy, shapes are metadata)."""
        lines = []
        out_tensor = ir.tensors.get(op.outputs[0])
        if out_tensor and op.inputs:
            inp = self._safe_c_name(op.inputs[0])
            out = self._safe_c_name(op.outputs[0])
            lines.append(f"    // Reshape is a no-op copy")
            lines.append(f"    for (int i = 0; i < {out_tensor.numel}; i++) {{")
            lines.append(f"        {out}[i] = {inp}[i];")
            lines.append("    }")
        return lines

    def _generate_main_function(self, ir: ACALSimIR, name: str) -> List[str]:
        """Generate main() for standalone execution."""
        # Calculate total input/output sizes
        total_input = sum(ir.tensors[n].numel for n in ir.input_names if n in ir.tensors)
        total_output = sum(ir.tensors[n].numel for n in ir.output_names if n in ir.tensors)

        lines = [
            "// Main function for standalone execution",
            "int main(void) {",
            f"    static float inputs[{max(total_input, 1)}];",
            f"    static float outputs[{max(total_output, 1)}];",
            "",
            "    // Initialize with test data",
            f"    for (int i = 0; i < {total_input}; i++) {{",
            "        inputs[i] = (float)(i % 10) / 10.0f;",
            "    }",
            "",
            f"    {name}_init();",
            f"    {name}_forward(inputs, outputs);",
            f"    {name}_cleanup();",
            "",
            "    // Signal completion via MMIO",
            "    MMIO_WRITE32(ECHO_DEVICE_BASE, 0xDEADBEEF);",
            "",
            "    return 0;",
            "}",
            "",
        ]
        return lines

    def _generate_weights_c(self, ir: ACALSimIR, name: str) -> str:
        """Generate C file with weight arrays."""
        lines = [
            "// Auto-generated weight data",
            f'#include "{name}.h"',
            "",
        ]

        for const_name, data in ir.constants.items():
            safe_name = self._safe_c_name(const_name)
            flat_data = data.flatten().astype(np.float32)

            lines.append(f"const float {safe_name}[{len(flat_data)}] = {{")

            # Write data in rows of 8
            for i in range(0, len(flat_data), 8):
                chunk = flat_data[i : i + 8]
                values = ", ".join(f"{v:.8g}f" for v in chunk)
                lines.append(f"    {values},")

            lines.append("};")
            lines.append("")

        return "\n".join(lines)

    def _generate_weight_data(self, ir: ACALSimIR, filepath: str) -> None:
        """Generate binary weight file."""
        with open(filepath, "wb") as f:
            for const_name, data in ir.constants.items():
                flat_data = data.flatten().astype(np.float32)
                f.write(flat_data.tobytes())

    def _generate_makefile(self, name: str) -> str:
        """Generate Makefile for RISC-V compilation."""
        return f"""# Auto-generated Makefile for ACALSim kernel
# Requires RISC-V toolchain

CROSS_COMPILE ?= riscv64-unknown-elf-
CC = $(CROSS_COMPILE)gcc
OBJCOPY = $(CROSS_COMPILE)objcopy
OBJDUMP = $(CROSS_COMPILE)objdump

CFLAGS = -march=rv64g -mabi=lp64d -O2 -nostdlib -nostartfiles
LDFLAGS = -T {name}.ld

TARGET = {name}
SRCS = {name}.c {name}_weights.c
OBJS = $(SRCS:.c=.o)

all: $(TARGET).elf $(TARGET).bin $(TARGET).dump

$(TARGET).elf: $(OBJS)
\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

$(TARGET).bin: $(TARGET).elf
\t$(OBJCOPY) -O binary $< $@

$(TARGET).dump: $(TARGET).elf
\t$(OBJDUMP) -d $< > $@

%.o: %.c
\t$(CC) $(CFLAGS) -c -o $@ $<

clean:
\trm -f $(OBJS) $(TARGET).elf $(TARGET).bin $(TARGET).dump

.PHONY: all clean
"""

    def _generate_linker_script(self, ir: ACALSimIR) -> str:
        """Generate linker script for bare-metal execution."""
        # Calculate memory needed
        total_memory = ir.estimate_memory() + 0x10000  # Add stack space

        return f"""/* Auto-generated linker script for ACALSim kernel */

ENTRY(_start)

MEMORY
{{
    RAM (rwx) : ORIGIN = 0x80000000, LENGTH = {max(total_memory, 0x100000)}
}}

SECTIONS
{{
    .text : {{
        _start = .;
        *(.text.init)
        *(.text .text.*)
    }} > RAM

    .rodata : {{
        *(.rodata .rodata.*)
    }} > RAM

    .data : {{
        *(.data .data.*)
    }} > RAM

    .bss : {{
        __bss_start = .;
        *(.bss .bss.*)
        *(COMMON)
        __bss_end = .;
    }} > RAM

    .stack : {{
        . = ALIGN(16);
        . = . + 0x4000;  /* 16KB stack */
        __stack_top = .;
    }} > RAM
}}
"""

    def _safe_c_name(self, name: str) -> str:
        """Convert tensor name to valid C identifier."""
        safe = name.replace(".", "_").replace("-", "_")
        if safe[0].isdigit():
            safe = "t_" + safe
        return safe
