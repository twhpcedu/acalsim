// Auto-generated by ACALSim PyTorch Backend
// Graph: graph_0

#include "graph_0.h"

#include <stddef.h>

// MMIO helper macros
#define MMIO_WRITE32(addr, val)     (*(volatile uint32_t*)(addr) = (val))
#define MMIO_READ32(addr)           (*(volatile uint32_t*)(addr))
#define MMIO_WRITE_FLOAT(addr, val) (*(volatile float*)(addr) = (val))
#define MMIO_READ_FLOAT(addr)       (*(volatile float*)(addr))

// Wait for device to be ready
static inline void wait_device_ready(void) {
	while (MMIO_READ32(COMPUTE_DEVICE_BASE + REG_STATUS) != 0) {
		// Busy wait
	}
}

// Tensor buffers
static float input_0[64];
static float t_2[128];
static float t_3[128];
static float t_5[64];
static float t_6[64];
static float t_8[32];

// External weight data
extern const float param_1[];
extern const float param_4[];
extern const float param_7[];

void graph_0_init(void) {
	// Initialize device
	MMIO_WRITE32(COMPUTE_DEVICE_BASE + REG_CMD, CMD_NOP);
	wait_device_ready();
}

void graph_0_forward(float* inputs, float* outputs) {
	// Copy input to input_0
	for (int i = 0; i < 64; i++) { input_0[i] = inputs[0 + i]; }

	// Op 0: t_2 = MATMUL(input_0, param_1)
	// MATMUL: [4x16] @ [16x32] -> [4x32]
	for (int m = 0; m < 4; m++) {
		for (int n = 0; n < 32; n++) {
			float sum = 0.0f;
			for (int k = 0; k < 16; k++) { sum += input_0[m * 16 + k] * param_1[k * 32 + n]; }
			t_2[m * 32 + n] = sum;
		}
	}

	// Op 1: t_3 = RELU(t_2)
	for (int i = 0; i < 128; i++) { t_3[i] = t_2[i] > 0 ? t_2[i] : 0; }

	// Op 2: t_5 = MATMUL(t_3, param_4)
	// MATMUL: [4x32] @ [32x16] -> [4x16]
	for (int m = 0; m < 4; m++) {
		for (int n = 0; n < 16; n++) {
			float sum = 0.0f;
			for (int k = 0; k < 32; k++) { sum += t_3[m * 32 + k] * param_4[k * 16 + n]; }
			t_5[m * 16 + n] = sum;
		}
	}

	// Op 3: t_6 = RELU(t_5)
	for (int i = 0; i < 64; i++) { t_6[i] = t_5[i] > 0 ? t_5[i] : 0; }

	// Op 4: t_8 = MATMUL(t_6, param_7)
	// MATMUL: [4x16] @ [16x8] -> [4x8]
	for (int m = 0; m < 4; m++) {
		for (int n = 0; n < 8; n++) {
			float sum = 0.0f;
			for (int k = 0; k < 16; k++) { sum += t_6[m * 16 + k] * param_7[k * 8 + n]; }
			t_8[m * 8 + n] = sum;
		}
	}

	// Copy output from t_8
	for (int i = 0; i < 32; i++) { outputs[0 + i] = t_8[i]; }
}

void graph_0_cleanup(void) {
	// Cleanup - nothing to do for static buffers
}

// Main function for standalone execution
int main(void) {
	static float inputs[64];
	static float outputs[32];

	// Initialize with test data
	for (int i = 0; i < 64; i++) { inputs[i] = (float)(i % 10) / 10.0f; }

	graph_0_init();
	graph_0_forward(inputs, outputs);
	graph_0_cleanup();

	// Signal completion via MMIO
	MMIO_WRITE32(ECHO_DEVICE_BASE, 0xDEADBEEF);

	return 0;
}
