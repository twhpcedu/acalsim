// Auto-generated by ACALSim PyTorch Backend
// Graph: graph_0

#include "graph_0.h"

#include <stddef.h>

// MMIO helper macros
#define MMIO_WRITE32(addr, val)     (*(volatile uint32_t*)(addr) = (val))
#define MMIO_READ32(addr)           (*(volatile uint32_t*)(addr))
#define MMIO_WRITE_FLOAT(addr, val) (*(volatile float*)(addr) = (val))
#define MMIO_READ_FLOAT(addr)       (*(volatile float*)(addr))

// Wait for device to be ready
static inline void wait_device_ready(void) {
	while (MMIO_READ32(COMPUTE_DEVICE_BASE + REG_STATUS) != 0) {
		// Busy wait
	}
}

// Tensor buffers
static float input_0[128];
static float t_2[64];
static float t_4[64];

// External weight data
extern const float param_1[];
extern const float param_3[];

void graph_0_init(void) {
	// Initialize device
	MMIO_WRITE32(COMPUTE_DEVICE_BASE + REG_CMD, CMD_NOP);
	wait_device_ready();
}

void graph_0_forward(float* inputs, float* outputs) {
	// Copy input to input_0
	for (int i = 0; i < 128; i++) { input_0[i] = inputs[0 + i]; }

	// Op 0: t_2 = MATMUL(input_0, param_1)
	// MATMUL: [8x16] @ [16x8] -> [8x8]
	for (int m = 0; m < 8; m++) {
		for (int n = 0; n < 8; n++) {
			float sum = 0.0f;
			for (int k = 0; k < 16; k++) { sum += input_0[m * 16 + k] * param_1[k * 8 + n]; }
			t_2[m * 8 + n] = sum;
		}
	}

	// Op 1: t_4 = ADD(t_2, param_3)
	for (int i = 0; i < 64; i++) { t_4[i] = t_2[i] + param_3[i]; }

	// Copy output from t_4
	for (int i = 0; i < 64; i++) { outputs[0 + i] = t_4[i]; }
}

void graph_0_cleanup(void) {
	// Cleanup - nothing to do for static buffers
}

// Main function for standalone execution
int main(void) {
	static float inputs[128];
	static float outputs[64];

	// Initialize with test data
	for (int i = 0; i < 128; i++) { inputs[i] = (float)(i % 10) / 10.0f; }

	graph_0_init();
	graph_0_forward(inputs, outputs);
	graph_0_cleanup();

	// Signal completion via MMIO
	MMIO_WRITE32(ECHO_DEVICE_BASE, 0xDEADBEEF);

	return 0;
}
