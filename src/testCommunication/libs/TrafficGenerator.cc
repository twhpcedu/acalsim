/*
 * Copyright 2023-2025 Playlab/ACAL
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file TrafficGenerator.cc
 * @brief Traffic generator implementation for PE communication testing
 *
 * This file implements a traffic generator that injects computational requests
 * into Processing Elements (PEs) using channel-based event delivery. It demonstrates
 * event-driven traffic injection, callback-based response handling, and transaction
 * tracking.
 *
 * **Traffic Generator Role:**
 *
 * The TrafficGenerator acts as a traffic source in the system:
 * ```
 * TrafficGenerator ──────────► PE
 *   (Traffic Injection)    (Request Processing)
 *         │                        │
 *    Create Event            Compute Result
 *         │                        │
 *    Send via Channel        Invoke Callback
 *         │                        │
 *         └────────◄───────────────┘
 *              (Response via Callback)
 * ```
 *
 * **Traffic Injection Flow:**
 *
 * During initialization (init()):
 * ```
 * 1. Create TrafficEvent with transaction ID
 * 2. Schedule event for future tick (tick + 1, tick + 2, etc.)
 * 3. Repeat for multiple transactions
 * ```
 *
 * When TrafficEvent executes:
 * ```
 * 4. Create PEReqPacket with computation parameters (a, b, c)
 * 5. Create PERespPacket to hold result
 * 6. Define callback lambda for response handling
 * 7. Create PEReqEvent with callback
 * 8. Wrap in EventPacket with target execution tick
 * 9. Push to MasterChannelPort "DSPE"
 * ```
 *
 * When PE completes computation:
 * ```
 * 10. PE invokes callback with transaction ID and result packet
 * 11. PERespHandler() extracts and logs result
 * 12. Clean up response packet
 * ```
 *
 * **Transaction Management:**
 *
 * Each traffic injection has:
 * - Transaction ID (_tID): Unique identifier for tracking
 * - Request parameters: (a, b, c) for computation d = a*b + c
 * - Response packet: Pre-allocated to receive result
 * - Callback function: Invoked when PE completes processing
 *
 * **Event Scheduling Strategy:**
 *
 * This example uses staggered scheduling:
 * ```
 * Tick 1: TrafficEvent #1 injects request (scheduled at init)
 * Tick 2: TrafficEvent #2 injects request (scheduled at init)
 * Tick 6: PE processes request #1 (scheduled by TrafficEvent #1)
 * Tick 7: PE processes request #2 (scheduled by TrafficEvent #2)
 * ```
 *
 * Alternative strategies:
 * - Periodic: Schedule events at regular intervals
 * - Poisson: Random inter-arrival times for realistic traffic
 * - Burst: Multiple requests in quick succession
 * - Trace-driven: Replay recorded traffic patterns
 *
 * **Channel Communication Details:**
 *
 * TrafficGenerator uses MasterChannelPort "DSPE":
 * ```cpp
 * this->pushToMasterChannelPort("DSPE", eventPkt);
 * ```
 *
 * What happens:
 * 1. EventPacket placed in channel's master queue
 * 2. During Phase 2, ChannelPortManager transfers packet
 * 3. Packet arrives at PE's SlaveChannelPort "USTrafficGenerator"
 * 4. Framework extracts SimEvent from EventPacket
 * 5. Event scheduled in PE's event queue for target tick
 *
 * **Callback Pattern:**
 *
 * Callbacks enable asynchronous response handling:
 * ```cpp
 * std::function<void(int, PERespPacket*)> callback =
 *     [this, peRespPkt](int id, PERespPacket* pkt) {
 *         dynamic_cast<TrafficGenerator*>(this->sim)->PERespHandler(id, pkt);
 *     };
 * ```
 *
 * Benefits:
 * - Decouples request and response timing
 * - No need for response channels
 * - Transaction context preserved via closure
 * - Flexible response handling logic
 *
 * **Design Patterns:**
 *
 * 1. **Event-Driven Architecture**
 *    - Traffic generated by scheduled events
 *    - Responses handled via callbacks
 *    - No polling or blocking
 *
 * 2. **Request-Response Protocol**
 *    - Each request has unique transaction ID
 *    - Response matched to request via callback
 *    - Pre-allocated response packets for efficiency
 *
 * 3. **Channel-Based Communication**
 *    - Asynchronous message passing
 *    - Decoupled sender and receiver
 *    - Framework-managed timing
 *
 * **Extension Points:**
 *
 * This TrafficGenerator can be extended to:
 * - Support multiple PE destinations (PE mesh)
 * - Implement realistic traffic patterns (Poisson, traces)
 * - Add traffic shaping and rate limiting
 * - Support different request types
 * - Collect performance statistics (latency, throughput)
 * - Implement flow control mechanisms
 *
 * @see TrafficGenerator.hh for class definition
 * @see TrafficEvent.cc for event injection logic
 * @see PEReq.cc for request/response packet types
 * @see PEEvent.cc for PE-side event processing
 */

#include "TrafficGenerator.hh"

#include "DataReq.hh"
#include "PEEvent.hh"
#include "PEReq.hh"
#include "TrafficEvent.hh"

/**
 * @brief Initialize traffic generator and schedule initial events
 *
 * This method is called by the framework during the initialization phase
 * (before simulation run loop starts). It sets up the initial traffic
 * injection by scheduling TrafficEvents for future ticks.
 *
 * **Initialization Flow:**
 * ```
 * 1. Called by SimTop::init() for each simulator
 * 2. Create TrafficEvent objects with unique transaction IDs
 * 3. Schedule events for specific ticks
 * 4. Events will trigger during simulation run phase
 * ```
 *
 * **Event Creation Pattern:**
 * ```cpp
 * int _tID = 1;  // Transaction ID for tracking
 * TrafficEvent* tfEvent_1 = new TrafficEvent(
 *     this,                           // Pointer to this simulator
 *     "TestEventFromTG2PE_1",         // Event name for debugging
 *     _tID                            // Transaction ID
 * );
 * this->scheduleEvent(tfEvent_1, top->getGlobalTick() + 1);
 * ```
 *
 * **Scheduling Timing:**
 * - Event #1: Scheduled for tick 1 (getGlobalTick() + 1, where global tick = 0)
 * - Event #2: Scheduled for tick 2 (getGlobalTick() + 2)
 *
 * At initialization, global tick is typically 0, so:
 * - tick 0: Initialization phase
 * - tick 1: TrafficEvent #1 executes → sends request to PE
 * - tick 2: TrafficEvent #2 executes → sends request to PE
 *
 * **Why Schedule at Init?**
 *
 * Benefits:
 * - All traffic timing decided upfront
 * - Predictable, repeatable behavior
 * - Simple to understand and debug
 * - No runtime scheduling logic needed
 *
 * Alternative approaches:
 * - Dynamic scheduling: Events schedule follow-up events
 * - Periodic generation: Use step() method for regular traffic
 * - External triggers: Respond to other events in system
 *
 * **Transaction ID Management:**
 *
 * Each event gets unique ID for tracking:
 * - Enables request-response matching
 * - Facilitates performance analysis
 * - Simplifies debugging (trace specific transactions)
 * - Required for concurrent outstanding requests
 *
 * **Memory Management:**
 * - TrafficEvent objects allocated with new
 * - Framework takes ownership via scheduleEvent()
 * - Events auto-deleted after process() completes (unless Managed flag set)
 * - No manual cleanup needed in this example
 *
 * **Extension Example - Periodic Traffic:**
 * ```cpp
 * void TrafficGenerator::init() {
 *     // Schedule first event
 *     TrafficEvent* event = new TrafficEvent(this, "Traffic", nextTID++);
 *     this->scheduleEvent(event, top->getGlobalTick() + 10);
 * }
 *
 * void TrafficGenerator::step() {
 *     // Called every tick - could generate traffic here
 *     if (top->getGlobalTick() % 10 == 0) {
 *         // Generate traffic every 10 ticks
 *     }
 * }
 * ```
 *
 * @note The current implementation schedules only 2 events for simplicity.
 *       Real traffic generators would schedule many events or use dynamic
 *       generation based on traffic patterns.
 *
 * @see TrafficEvent::process() for what happens when events execute
 * @see SimBase::scheduleEvent() for event scheduling API
 */
void TrafficGenerator::init() {
	// insert event in PE's event queue through channel
	int           _tID      = 1;
	TrafficEvent* tfEvent_1 = new TrafficEvent(this, "TestEventFromTG2PE_1", _tID);
	this->scheduleEvent(tfEvent_1, top->getGlobalTick() + 1);
	_tID                    = 2;
	TrafficEvent* tfEvent_2 = new TrafficEvent(this, "TestEventFromTG2PE_2", _tID);
	this->scheduleEvent(tfEvent_2, top->getGlobalTick() + 2);
}

/**
 * @brief Handle PE response callback for completed computation
 *
 * This method is invoked as a callback when the PE completes processing a request.
 * It demonstrates the response path of the request-response protocol using callbacks
 * instead of explicit response packets through channels.
 *
 * **Callback Invocation Path:**
 * ```
 * 1. TrafficEvent creates callback lambda referencing this method
 * 2. Callback passed to PEReqEvent via PEReqPacket
 * 3. PE processes request in PEReqEvent::process()
 * 4. PE invokes callback with transaction ID and response packet
 * 5. This method extracts and processes result
 * ```
 *
 * **Call Chain:**
 * ```
 * TrafficEvent::process()
 *   └─► Creates callback: [this](int id, PERespPacket* pkt) {
 *         TrafficGenerator::PERespHandler(id, pkt);
 *       }
 *   └─► Passes callback to PEReqEvent
 *
 * PEReqEvent::process() (executed at PE)
 *   └─► Computes result: d = a*b + c
 *   └─► Updates PERespPacket with result
 *   └─► Invokes: callerCallback(tid, respPkt)
 *
 * TrafficGenerator::PERespHandler()
 *   └─► Extracts result from packet
 *   └─► Logs completion
 *   └─► Frees response packet
 * ```
 *
 * **Response Processing:**
 * ```cpp
 * int result = pkt->getResult();  // Extract computed value
 * CLASS_INFO << "Result: " << result;  // Log for verification
 * free(pkt);  // Clean up response packet
 * ```
 *
 * **Transaction Tracking:**
 *
 * The transaction ID parameter enables:
 * - Matching responses to requests
 * - Calculating per-transaction latency
 * - Tracking outstanding requests
 * - Debugging specific transactions
 *
 * Example with latency tracking:
 * ```cpp
 * void TrafficGenerator::PERespHandler(int id, PERespPacket* pkt) {
 *     Tick completionTime = top->getGlobalTick();
 *     Tick latency = completionTime - requestTime[id];
 *     CLASS_INFO << "Transaction " << id << " latency: " << latency;
 *     totalLatency += latency;
 *     completedRequests++;
 * }
 * ```
 *
 * **Memory Management:**
 * - Response packet allocated by TrafficEvent
 * - Ownership passed through callback
 * - This method responsible for freeing (free(pkt))
 * - Request packet freed by PEReqEvent
 *
 * **Design Rationale - Why Callbacks?**
 *
 * Advantages over channel-based responses:
 * 1. No need for reverse channel setup
 * 2. Transaction context preserved automatically
 * 3. Lower latency (no channel transfer delay)
 * 4. Simpler response routing logic
 * 5. Reduced memory overhead
 *
 * When to use channels instead:
 * - Multi-hop response path needed
 * - Response delay modeling required
 * - Response buffering/queuing needed
 * - Different receiver than original sender
 *
 * **Callback vs Channel Comparison:**
 *
 * Callback approach (this example):
 * ```
 * TG ──request──► PE ──callback──► TG.PERespHandler()
 *    (channel)       (immediate)
 * ```
 *
 * Channel approach (alternative):
 * ```
 * TG ──request──► PE ──response──► TG (via channel port)
 *    (channel)       (channel)
 * ```
 *
 * **Error Handling:**
 *
 * Current implementation assumes success. Could be extended:
 * ```cpp
 * void TrafficGenerator::PERespHandler(int id, PERespPacket* pkt) {
 *     if (pkt->hasError()) {
 *         CLASS_ERROR << "Request " << id << " failed";
 *         retryRequest(id);
 *     } else {
 *         CLASS_INFO << "Request " << id << " succeeded";
 *         processResult(pkt->getResult());
 *     }
 *     free(pkt);
 * }
 * ```
 *
 * **Thread Safety:**
 *
 * In this simulation framework:
 * - Callbacks execute in event processing context
 * - Single-threaded event processing guarantees safety
 * - No mutex/locks needed for callback execution
 * - Multi-threaded frameworks would require synchronization
 *
 * @param id Transaction ID of the completed request
 * @param pkt Response packet containing computation result
 *
 * @note The method frees the response packet but not the request packet
 *       (PEReqEvent is responsible for request packet cleanup).
 *
 * @warning Using free() instead of delete - ensure packet allocated with malloc()
 *          or change to delete if using new operator.
 *
 * @see TrafficEvent::process() for callback creation
 * @see PEReqEvent::process() for callback invocation
 * @see PERespPacket for response packet structure
 */
void TrafficGenerator::PERespHandler(int id, PERespPacket* pkt) {
	CLASS_INFO << "Receive PERespPacket with transaction id: " << id;
	CLASS_INFO << "Receive PE computation result : " << pkt->getResult();
	free(pkt);
}

/**
 * @brief Clean up resources during simulation shutdown
 *
 * This method is called by the framework during the cleanup phase (after
 * simulation run loop completes). It's responsible for releasing dynamically
 * allocated memory, clearing event queues, and resetting state.
 *
 * **Cleanup Phase:**
 * ```
 * 1. Simulation run loop completes
 * 2. SimTop::finish() called
 * 3. Framework calls cleanup() for each simulator
 * 4. Resources released, statistics collected
 * ```
 *
 * **Current Implementation:**
 *
 * The current implementation is a stub (TODO comment). This is acceptable
 * because:
 * - TrafficEvents auto-deleted by framework after processing
 * - PERespPackets freed in PERespHandler()
 * - No persistent state to clean up
 * - Framework handles channel port cleanup
 *
 * **Potential Cleanup Tasks:**
 *
 * If the TrafficGenerator were more complex, cleanup might include:
 *
 * ```cpp
 * void TrafficGenerator::cleanup() {
 *     // 1. Cancel pending events
 *     while (!eventQueue.empty()) {
 *         SimEvent* event = eventQueue.pop();
 *         delete event;
 *     }
 *
 *     // 2. Clean up outstanding requests
 *     for (auto& [tid, reqPkt] : outstandingRequests) {
 *         delete reqPkt;
 *     }
 *     outstandingRequests.clear();
 *
 *     // 3. Release traffic pattern data
 *     delete trafficPattern;
 *
 *     // 4. Print statistics
 *     CLASS_INFO << "Total requests sent: " << totalRequests;
 *     CLASS_INFO << "Average latency: " << totalLatency / completedRequests;
 *
 *     // 5. Close trace files
 *     if (traceFile.is_open()) {
 *         traceFile.close();
 *     }
 * }
 * ```
 *
 * **Memory Leak Prevention:**
 *
 * Important cleanup considerations:
 * - Events scheduled but not yet executed
 * - Packets allocated but not sent
 * - Response packets for failed requests
 * - Callback closures capturing allocated memory
 * - File handles or network connections
 *
 * **Event Queue Cleanup:**
 *
 * If events remain in queue at shutdown:
 * ```cpp
 * // Framework provides event queue access
 * // Iterate and delete unprocessed events
 * // Or rely on framework's automatic cleanup
 * ```
 *
 * **Statistics Collection:**
 *
 * Cleanup is ideal for final statistics:
 * ```cpp
 * void TrafficGenerator::cleanup() {
 *     double avgLatency = totalLatency / completedRequests;
 *     double throughput = completedRequests / top->getGlobalTick();
 *
 *     CLASS_INFO << "=== Traffic Generator Statistics ===";
 *     CLASS_INFO << "Requests sent:    " << totalRequests;
 *     CLASS_INFO << "Requests completed: " << completedRequests;
 *     CLASS_INFO << "Average latency:   " << avgLatency << " ticks";
 *     CLASS_INFO << "Throughput:        " << throughput << " req/tick";
 * }
 * ```
 *
 * **Cleanup vs Destructor:**
 *
 * Why cleanup() instead of destructor:
 * - cleanup() called while simulation still active
 * - Can access framework state (top, other simulators)
 * - Allows coordinated multi-simulator cleanup
 * - Destructor called after framework shutdown
 *
 * **Best Practices:**
 *
 * 1. Always implement cleanup() even if currently empty
 * 2. Document what resources need cleanup
 * 3. Use RAII where possible to minimize manual cleanup
 * 4. Log cleanup actions for debugging
 * 5. Handle partial initialization gracefully
 *
 * @note Current implementation is a placeholder. Real implementations
 *       should release all dynamically allocated resources.
 *
 * @see SimBase::cleanup() for cleanup interface
 * @see SimTop::finish() for cleanup orchestration
 */
void TrafficGenerator::cleanup() {
	// TODO: Release the dynamic memory, clean up the event queue, ...etc.

	// clean up the event queue
}
