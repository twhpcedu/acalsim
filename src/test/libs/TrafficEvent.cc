/*
 * Copyright 2023-2026 Playlab/ACAL
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file TrafficEvent.cc
 * @brief Traffic event implementation for cross-simulator event generation and callback handling
 *
 * This file implements the **TrafficEvent** class, which represents memory access requests
 * generated by the TrafficGenerator simulator. It demonstrates **cross-simulator event routing**,
 * **callback-based event completion**, and **event lifecycle management** in the ACALSim framework.
 *
 * **Event Role and Purpose:**
 * ```
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                          TrafficEvent                                    │
 * │                     (SimEvent derived)                                   │
 * │                                                                           │
 * │  Purpose:                                                                 │
 * │  ┌────────────────────────────────────────────────────────────────────┐ │
 * │  │ 1. Represent memory traffic requests from TrafficGenerator        │ │
 * │  │ 2. Create and schedule downstream NocEvent                         │ │
 * │  │ 3. Provide callback mechanism for event completion notification   │ │
 * │  │ 4. Demonstrate cross-simulator event creation pattern             │ │
 * │  │ 5. Manage event memory lifecycle (unmanaged allocation)            │ │
 * │  └────────────────────────────────────────────────────────────────────┘ │
 * │                                                                           │
 * │  Event Lifecycle:                                                         │
 * │  ┌────────────────────────────────────────────────────────────────────┐ │
 * │  │ Creation    → Scheduling → Processing → Callback → Release        │ │
 * │  │ (init())      (tick N)     (tick N)     (tick N+10) (in callback) │ │
 * │  └────────────────────────────────────────────────────────────────────┘ │
 * │                                                                           │
 * │  Key Members:                                                             │
 * │  - sim: Pointer to parent TrafficGenerator simulator                     │
 * │  - id: Unique identifier for this traffic request                        │
 * │  - _name: Event name (e.g., "TrafficEvent_1")                            │
 * └─────────────────────────────────────────────────────────────────────────┘
 * ```
 *
 * **Event Processing Flow:**
 * ```
 * Tick 3 (Example - when TrafficEvent_1 is scheduled):
 *
 * Step 1: Framework invokes process() method
 *   └─► TrafficEvent::process() called
 *
 * Step 2: Log event processing
 *   └─► CLASS_INFO << "TrafficEvent Processed."
 *   └─► Output: [TrafficGenerator] TrafficEvent Processed.
 *
 * Step 3: Create downstream NocEvent with callback
 *   └─► NocEvent* nocEvent = new NocEvent(
 *           0,                          // Routing ID (placeholder)
 *           "TestEventFromPE2NOC",      // Descriptive event name
 *           [this] { callback(); }      // Lambda captures 'this' for callback
 *       );
 *   └─► Lambda capture enables deferred callback execution
 *   └─► Callback will be invoked when NocEvent completes
 *
 * Step 4: Get downstream NOC simulator
 *   └─► SimBase* noc = sim->getDownStream("DSNOC");
 *   └─► Lookup connection by name "DSNOC"
 *   └─► CLASS_ASSERT(noc) - verify connection exists
 *
 * Step 5: Schedule NocEvent in downstream simulator
 *   └─► noc->scheduleEvent((SimEvent*)nocEvent, top->getGlobalTick() + 10);
 *   └─► Event scheduled 10 ticks in the future
 *   └─► Current tick: 3, Target tick: 13
 *
 * Tick 13 (When NocEvent processes):
 *
 * Step 6: NocEvent::process() executes
 *   └─► Logs: "NocEvent Processed."
 *   └─► Invokes callback: callback() if provided
 *
 * Step 7: Callback execution
 *   └─► TrafficEvent::callback() invoked via lambda
 *   └─► Logs: "TrafficEvent Callback()"
 *   └─► this->releaseImpl() - release event memory
 *
 * Complete Event Flow Visualization:
 *   Tick 3:  TrafficEvent::process()
 *              │
 *              ├─► Log "TrafficEvent Processed"
 *              │
 *              ├─► Create NocEvent with callback
 *              │
 *              └─► Schedule NocEvent @ tick 13
 *
 *   Tick 13: NocEvent::process()
 *              │
 *              ├─► Log "NocEvent Processed"
 *              │
 *              └─► Execute callback
 *                    │
 *                    └─► TrafficEvent::callback()
 *                          │
 *                          ├─► Log "TrafficEvent Callback()"
 *                          │
 *                          └─► releaseImpl() - cleanup
 * ```
 *
 * **Cross-Simulator Event Creation Pattern:**
 * ```cpp
 * void TrafficEvent::process() {
 *     // Step 1: Log processing
 *     CLASS_INFO << "TrafficEvent Processed.";
 *
 *     // Step 2: Create event for downstream simulator
 *     // Lambda [this] captures the TrafficEvent instance
 *     // Callback will be executed when NocEvent completes
 *     NocEvent* nocEvent = new NocEvent(
 *         0,                              // Routing/PE ID
 *         "TestEventFromPE2NOC",          // Event identifier
 *         [this] { callback(); }          // Completion callback
 *     );
 *
 *     // Step 3: Get downstream simulator via connection name
 *     // "DSNOC" is the connection name set in test.cc
 *     SimBase* noc = sim->getDownStream("DSNOC");
 *     CLASS_ASSERT(noc);  // Verify connection is valid
 *
 *     // Step 4: Schedule event in downstream simulator
 *     // Use global tick for consistent timing across simulators
 *     noc->scheduleEvent(
 *         (SimEvent*)nocEvent,           // Event to schedule
 *         top->getGlobalTick() + 10      // Target tick (10 cycles latency)
 *     );
 * }
 * ```
 *
 * **Callback Mechanism and Lambda Capture:**
 * ```
 * Lambda Capture Explanation:
 *
 * [this] { callback(); }
 *   │       │
 *   │       └─► Call callback() method of captured object
 *   │
 *   └─► Capture 'this' pointer (the TrafficEvent instance)
 *
 * Why Lambda Capture?
 * 1. Deferred Execution: Callback runs later (tick 13 vs tick 3)
 * 2. Context Preservation: Maintains reference to TrafficEvent
 * 3. Cross-Simulator Communication: NocEvent can notify TrafficEvent
 * 4. Resource Cleanup: Enables event to clean itself up on completion
 *
 * Callback Execution Flow:
 *   NocEvent stores callback: std::function<void(void)> callback
 *   │
 *   ├─► When NocEvent::process() runs:
 *   │     if (callback) { callback(); }
 *   │
 *   └─► Invokes TrafficEvent::callback():
 *         - Logs completion message
 *         - Calls releaseImpl() to free memory
 *         - Completes event lifecycle
 * ```
 *
 * **Memory Management and Event Lifecycle:**
 * ```
 * Event Allocation (in TrafficGenerator::init()):
 *   TrafficEvent* traffic_event = new TrafficEvent(this, i, std::to_string(i));
 *   - Dynamic allocation on heap
 *   - Constructor sets clearFlags(Managed) - unmanaged event
 *   - Caller responsible for cleanup
 *
 * Event Lifecycle States:
 *   1. Created:     new TrafficEvent(...)
 *   2. Scheduled:   scheduleEvent(traffic_event, tick)
 *   3. Pending:     Waiting in event queue
 *   4. Processing:  process() method executing
 *   5. Waiting:     Callback pending (NocEvent executing)
 *   6. Completed:   callback() invoked
 *   7. Released:    releaseImpl() called
 *
 * Memory Cleanup:
 *   void TrafficEvent::callback() {
 *       CLASS_INFO << "TrafficEvent Callback()";
 *       this->releaseImpl();  // Manual release required
 *   }
 *
 * Why Unmanaged Events?
 *   - Fine-grained control over lifecycle
 *   - Callback-based completion detection
 *   - Support for cross-simulator event flows
 *   - Explicit cleanup timing
 * ```
 *
 * **Event Name Construction:**
 * ```cpp
 * // In constructor (TrafficEvent.hh):
 * TrafficEvent(SimBase* _sim, int _id, std::string name)
 *     : SimEvent(),
 *       sim(_sim),
 *       id(_id),
 *       _name("TrafficEvent_" + name)  // Prefix + supplied name
 * {
 *     this->clearFlags(this->Managed);  // Unmanaged memory
 * }
 *
 * // Example usage (from TrafficGenerator::init()):
 * TrafficEvent* event = new TrafficEvent(this, 1, "1");
 * // Results in: _name = "TrafficEvent_1"
 *
 * TrafficEvent* event = new TrafficEvent(this, 5, "5");
 * // Results in: _name = "TrafficEvent_5"
 *
 * // Name is used for:
 * // - Logging and debugging
 * // - Event identification in traces
 * // - Performance analysis
 * ```
 *
 * **Connection Lookup and Validation:**
 * ```cpp
 * // Get downstream connection by name
 * SimBase* noc = sim->getDownStream("DSNOC");
 *
 * // Validate connection exists
 * CLASS_ASSERT(noc);
 *
 * // Connection is established in test.cc:
 * // trafficGenerator->addDownStream(nocSim, "DSNOC");
 *
 * // Why string-based lookup?
 * // 1. Flexible reconfiguration - change connections at runtime
 * // 2. Decoupling - TrafficEvent doesn't need direct NOC reference
 * // 3. Multiple connections - single simulator can have many ports
 * // 4. Topology independence - same event code works with different topologies
 *
 * // Alternative: Direct pointer (tighter coupling)
 * // class TrafficEvent {
 * //     NocSim* noc;  // Direct reference
 * // };
 * // Less flexible but faster lookup
 * ```
 *
 * **Timing and Latency Modeling:**
 * ```
 * Event Scheduling with Latency:
 *
 * top->getGlobalTick() + 10
 *   │                    │
 *   │                    └─► Latency: 10 cycles
 *   │                        - Represents NOC traversal time
 *   │                        - Could be configurable parameter
 *   │                        - Models communication delay
 *   │
 *   └─► Global tick: Synchronized across all simulators
 *       - Ensures consistent temporal ordering
 *       - Allows cross-simulator event scheduling
 *
 * Example Timeline:
 *   Current Tick: 3
 *   Global Tick: 3
 *   Latency: 10
 *   Target Tick: 3 + 10 = 13
 *
 *   Tick 3:  TrafficEvent processes, schedules NocEvent
 *   Tick 4-12: NOC latency period (event in queue)
 *   Tick 13: NocEvent processes, callback invoked
 *
 * Latency Modeling Extensions:
 *   // Variable latency based on NOC congestion
 *   Tick latency = baseLatency + contentionDelay;
 *
 *   // Distance-based latency (hop count)
 *   Tick latency = hopCount * hopLatency;
 *
 *   // Probabilistic latency (jitter modeling)
 *   std::normal_distribution<> dist(meanLatency, stddev);
 *   Tick latency = dist(rng);
 * ```
 *
 * **Extending TrafficEvent for Realistic Traffic:**
 * ```cpp
 * class TrafficEvent : public SimEvent {
 * private:
 *     // Memory access properties
 *     uint64_t address;        // Memory address
 *     uint32_t size;           // Access size in bytes
 *     AccessType type;         // READ, WRITE, RMW
 *     uint8_t* data;           // Data payload (for writes)
 *
 *     // Timing information
 *     Tick issueTime;          // When request was generated
 *     Tick completionTime;     // When response received
 *
 *     // Performance tracking
 *     std::function<void(Tick)> perfCallback;
 *
 * public:
 *     void process() override {
 *         CLASS_INFO << "Processing " << typeToString(type)
 *                    << " request to address 0x" << std::hex << address;
 *
 *         // Record issue time
 *         issueTime = top->getGlobalTick();
 *
 *         // Create NOC request with memory access details
 *         NocReqPacket* packet = new NocReqPacket(address, size, type);
 *
 *         // Create NOC event with enhanced callback
 *         NocEvent* nocEvent = new NocEvent(
 *             0,
 *             "MemReq_" + std::to_string(address),
 *             [this](uint8_t* responseData) {
 *                 handleResponse(responseData);
 *             }
 *         );
 *
 *         // Schedule with distance-aware latency
 *         SimBase* noc = sim->getDownStream("DSNOC");
 *         Tick latency = calculateNocLatency(address);
 *         noc->scheduleEvent(nocEvent, top->getGlobalTick() + latency);
 *     }
 *
 *     void handleResponse(uint8_t* responseData) {
 *         completionTime = top->getGlobalTick();
 *         Tick latency = completionTime - issueTime;
 *
 *         CLASS_INFO << "Request completed in " << latency << " cycles";
 *
 *         // Notify performance monitor
 *         if (perfCallback) {
 *             perfCallback(latency);
 *         }
 *
 *         // Process response data
 *         if (type == READ) {
 *             memcpy(data, responseData, size);
 *         }
 *
 *         this->releaseImpl();
 *     }
 * };
 * ```
 *
 * **Design Patterns Demonstrated:**
 *
 * 1. **Observer Pattern (Callback)**
 *    - TrafficEvent observes NocEvent completion
 *    - Loose coupling between event types
 *
 * 2. **Factory Pattern (Event Creation)**
 *    - TrafficEvent creates NocEvent
 *    - Cross-simulator event generation
 *
 * 3. **Command Pattern (Event as Command)**
 *    - Event encapsulates action (process)
 *    - Deferred execution via scheduling
 *
 * 4. **Chain of Responsibility**
 *    - Event flows through simulator chain
 *    - TrafficGenerator → NOC → Cache
 *
 * **Comparison with Managed Events:**
 *
 * | Aspect            | Unmanaged (this)      | Managed              |
 * |-------------------|-----------------------|----------------------|
 * | Memory Mgmt       | Manual (releaseImpl)  | Automatic            |
 * | Lifecycle Control | Explicit              | Framework-controlled |
 * | Callback Support  | Yes (required)        | Limited              |
 * | Use Case          | Cross-simulator       | Single simulator     |
 * | Cleanup Timing    | Precise (callback)    | After processing     |
 *
 * **Usage Example:**
 * ```cpp
 * // In TrafficGenerator::init():
 * for (Tick i = 1; i < 10; ++i) {
 *     TrafficEvent* event = new TrafficEvent(
 *         this,               // Simulator pointer
 *         i,                  // Event ID
 *         std::to_string(i)   // Name suffix
 *     );
 *     scheduleEvent(event, i * 2 + 1);
 * }
 *
 * // Framework execution:
 * // Tick 3: TrafficEvent_1 processes → schedules NocEvent @ tick 13
 * // Tick 5: TrafficEvent_2 processes → schedules NocEvent @ tick 15
 * // ...
 * // Tick 13: NocEvent from TrafficEvent_1 → callback → release
 * // Tick 15: NocEvent from TrafficEvent_2 → callback → release
 * ```
 *
 * **Debugging and Logging:**
 * ```
 * Log Output Pattern:
 *
 * [TrafficGenerator] TrafficEvent Processed.        ← process() log
 * [Noxim] NocEvent Processed.                       ← NocEvent::process() log
 * [TrafficGenerator] TrafficEvent Callback()        ← callback() log
 *
 * CLASS_INFO macro:
 * - Prepends simulator name
 * - Thread-safe logging
 * - Timestamp included (if enabled)
 * - Hierarchical log levels
 * ```
 *
 * @see test.cc Main test framework and topology setup
 * @see TrafficEvent.hh TrafficEvent class definition
 * @see TrafficGenerator.cc Traffic generator creating these events
 * @see NocEvent.cc Downstream NOC event handling callbacks
 * @see NocEvent.hh NocEvent class with callback support
 * @see SimEvent Base class for all events
 * @see SimBase Base class providing getDownStream/getUpStream
 */

#include "TrafficEvent.hh"

#include "NocEvent.hh"

void TrafficEvent::process() {
	CLASS_INFO << "TrafficEvent Processed.";

	NocEvent* nocEvent = new NocEvent(0, "TestEventFromPE2NOC", [this] { callback(); });
	// TODO: "DSNOC" can be replaced with a variable set in the SimTop::init() function
	// when the connection of simulators is made.
	SimBase* noc = sim->getDownStream("DSNOC");
	CLASS_ASSERT(noc);
	noc->scheduleEvent((SimEvent*)nocEvent, top->getGlobalTick() + 10);
}

void TrafficEvent::callback() {
	CLASS_INFO << "TrafficEvent Callback()";
	this->releaseImpl();
}
