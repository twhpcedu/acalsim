/*
 * Copyright 2023-2026 Playlab/ACAL
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file BasePacket.cc
 * @brief Packet hierarchy and visitor pattern implementation for testSimPort
 *
 * This file implements the **packet type system** and **visitor pattern** that enables
 * type-safe packet routing through the CPU-Bus-Memory system. It demonstrates how to
 * create custom packet types and use the framework's visitor mechanism for automatic
 * dispatching to correct handler methods.
 *
 * **Packet Class Hierarchy:**
 * ```
 * SimPacket (ACALSim framework base class)
 *   │
 *   └─► BasePacket (testSimPort base)
 *         │
 *         ├─► BaseReqPacket (Request packets: CPU → Memory)
 *         │     - Generated by CPUCore
 *         │     - Forwarded by CrossBar
 *         │     - Consumed by Memory
 *         │
 *         └─► BaseRspPacket (Response packets: Memory → CPU)
 *               - Generated by Memory
 *               - Forwarded by CrossBar
 *               - Consumed by CPUCore
 * ```
 *
 * **Packet Structure:**
 * ```
 * BasePacket:
 *   ├─ req_id_ (uint32_t)        // Unique request identifier
 *   ├─ visit(SimModule&)          // Module-level visitor (unused)
 *   └─ visit(SimBase&)            // Simulator-level visitor (overridden by subclasses)
 *
 * BaseReqPacket (inherits BasePacket):
 *   ├─ req_id_ (inherited)        // Request ID
 *   └─ visit(SimBase&)            // Routes to CrossBar or Memory handler
 *
 * BaseRspPacket (inherits BasePacket):
 *   ├─ req_id_ (inherited)        // Same ID as corresponding request
 *   └─ visit(SimBase&)            // Routes to CPUCore or CrossBar handler
 * ```
 *
 * **Visitor Pattern Implementation:**
 * ```
 * The visitor pattern enables type-safe packet routing without explicit type checks.
 *
 * Traditional Approach (what we avoid):
 *   void processPacket(SimPacket* pkt) {
 *       if (auto req = dynamic_cast<BaseReqPacket*>(pkt)) {
 *           handleRequest(req);
 *       } else if (auto rsp = dynamic_cast<BaseRspPacket*>(pkt)) {
 *           handleResponse(rsp);
 *       }
 *       // Requires if-else chain for every packet type
 *   }
 *
 * Visitor Pattern Approach (what we use):
 *   void processPacket(SimPacket* pkt, SimBase& simulator) {
 *       pkt->visit(tick, simulator);
 *       // Packet calls correct handler automatically
 *   }
 *
 * Benefits:
 *   - No manual type checking required
 *   - Compiler ensures all cases handled
 *   - Easy to add new packet types
 *   - Type-safe at compile time
 * ```
 *
 * **Visitor Pattern Flow:**
 * ```
 * Example: Request Packet Routing
 *
 * Step 1: CPU sends request to Bus
 *   cpu->m_port->push(req_packet);  // req_packet is BaseReqPacket*
 *
 * Step 2: Framework transfers packet to Bus (Phase 2)
 *   bus->s_port->receive(req_packet);
 *
 * Step 3: Bus calls accept() on packet (Phase 1, next cycle)
 *   bus->accept(tick, req_packet);
 *     └─► req_packet->visit(tick, *bus);  // Visit CrossBar
 *
 * Step 4: Packet dispatches to correct handler
 *   BaseReqPacket::visit(tick, simulator) {
 *       if (auto xbar = dynamic_cast<CrossBar*>(&simulator)) {
 *           xbar->handler(this);  // ◄─── Type-safe call to CrossBar::handler(BaseReqPacket*)
 *       } else if (auto mem = dynamic_cast<Memory*>(&simulator)) {
 *           mem->handler(this);   // ◄─── Type-safe call to Memory::handler(BaseReqPacket*)
 *       }
 *   }
 *
 * Step 5: Handler processes packet
 *   CrossBar::handler(BaseReqPacket* packet) {
 *       // Forward to memory...
 *   }
 * ```
 *
 * **Request Packet Lifecycle:**
 * ```
 * Creation (CPUCore):
 *   auto req = rc->acquire<BaseReqPacket>(&BaseReqPacket::renew, req_id);
 *   req->req_id_ = uniqueReqID++;
 *
 * Transmission (CPU → Bus):
 *   cpu->m_port->push(req);
 *
 * Visit at Bus:
 *   req->visit(tick, *bus);
 *     └─► bus->handler(req);  // CrossBar::handler(BaseReqPacket*)
 *
 * Transmission (Bus → Memory):
 *   bus->m_port_to_mem->push(req);
 *
 * Visit at Memory:
 *   req->visit(tick, *mem);
 *     └─► mem->handler(req);  // Memory::handler(BaseReqPacket*)
 *
 * Recycling (Memory):
 *   rc->recycle(req);  // Return to pool
 * ```
 *
 * **Response Packet Lifecycle:**
 * ```
 * Creation (Memory):
 *   auto rsp = rc->acquire<BaseRspPacket>(&BaseRspPacket::renew, req_id);
 *   rsp->req_id_ = req->getReqId();  // Match request ID
 *
 * Transmission (Memory → Bus):
 *   mem->m_port->push(rsp);
 *
 * Visit at Bus:
 *   rsp->visit(tick, *bus);
 *     └─► bus->handler(rsp);  // CrossBar::handler(BaseRspPacket*)
 *
 * Transmission (Bus → CPU):
 *   bus->m_port_to_cpu->push(rsp);
 *
 * Visit at CPU:
 *   rsp->visit(tick, *cpu);
 *     └─► cpu->handler(rsp);  // CPUCore::handler(BaseRspPacket*)
 *
 * Recycling (CPUCore):
 *   rc->recycle(rsp);  // Return to pool
 * ```
 *
 * **Request-Response Matching:**
 * ```
 * The req_id field enables matching responses with outstanding requests:
 *
 * CPUCore generates request:
 *   req_id = uniqueReqID++;  // E.g., 42
 *   outstanding_req_queue.add(42, true);
 *
 * Memory generates response:
 *   rsp->req_id_ = req->getReqId();  // Copy ID: 42
 *
 * CPUCore processes response:
 *   uint32_t id = rsp->getReqId();  // Extract: 42
 *   if (outstanding_req_queue.contains(id)) {
 *       outstanding_req_queue.remove(id);  // Match found!
 *       // Request complete
 *   }
 * ```
 *
 * **RecycleContainer Integration:**
 * ```
 * Packets are managed by RecycleContainer for efficient memory reuse:
 *
 * Acquisition:
 *   auto req = rc->acquire<BaseReqPacket>(
 *       &BaseReqPacket::renew,  // Renew function to call
 *       req_id                   // Argument to renew()
 *   );
 *
 * Renew Function:
 *   void BaseReqPacket::renew(uint32_t _req_id) {
 *       this->SimPacket::renew();  // Reset base class state
 *       this->req_id_ = _req_id;   // Initialize req_id
 *   }
 *
 * Recycling:
 *   rc->recycle(req);  // Return to pool for reuse
 *
 * Benefits:
 *   - No repeated new/delete calls
 *   - Reduced memory fragmentation
 *   - Improved cache locality
 *   - Faster simulation performance
 * ```
 *
 * **Handler Method Signatures:**
 * ```
 * CPUCore:
 *   void handler(BaseRspPacket* packet);  // Receives responses from bus
 *
 * CrossBar:
 *   void handler(BaseReqPacket* packet);  // Receives requests from CPU
 *   void handler(BaseRspPacket* packet);  // Receives responses from Memory
 *
 * Memory:
 *   void handler(BaseReqPacket* packet);  // Receives requests from bus
 * ```
 *
 * **Type Safety and Compile-Time Checks:**
 * ```
 * The visitor pattern provides compile-time type safety:
 *
 * Correct Usage:
 *   BaseReqPacket::visit(SimBase& simulator) {
 *       if (auto xbar = dynamic_cast<CrossBar*>(&simulator)) {
 *           xbar->handler(this);  // ✓ CrossBar::handler(BaseReqPacket*)
 *       }
 *   }
 *
 * Compile Error if Wrong Type:
 *   BaseReqPacket::visit(SimBase& simulator) {
 *       if (auto cpu = dynamic_cast<CPUCore*>(&simulator)) {
 *           cpu->handler(this);  // ✗ CPUCore has no handler(BaseReqPacket*)
 *       }
 *   }
 *   // Compiler error: CPUCore::handler() expects BaseRspPacket*, not BaseReqPacket*
 * ```
 *
 * **Extending with New Packet Types:**
 * ```cpp
 * // 1. Define new packet class
 * class PrefetchReqPacket : public BasePacket {
 * public:
 *     uint64_t addr;
 *     uint32_t size;
 *
 *     void renew(uint32_t _req_id, uint64_t _addr, uint32_t _size) {
 *         this->BasePacket::renew(_req_id);
 *         this->addr = _addr;
 *         this->size = _size;
 *     }
 *
 *     void visit(Tick when, SimBase& simulator) final {
 *         if (auto cache = dynamic_cast<Cache*>(&simulator)) {
 *             cache->handler(this);  // Cache::handler(PrefetchReqPacket*)
 *         }
 *     }
 * };
 *
 * // 2. Add handler in target simulator
 * class Cache : public CPPSimBase {
 * public:
 *     void handler(PrefetchReqPacket* packet) {
 *         // Process prefetch request...
 *     }
 * };
 *
 * // 3. Use in simulation
 * auto prefetch = rc->acquire<PrefetchReqPacket>(
 *     &PrefetchReqPacket::renew, req_id, addr, size
 * );
 * cache_port->push(prefetch);
 * ```
 *
 * **Common Packet Extensions:**
 *
 * 1. **Add Address Field:**
 *    ```cpp
 *    class AddrReqPacket : public BaseReqPacket {
 *        uint64_t addr;
 *        uint32_t size;
 *    };
 *    ```
 *
 * 2. **Add Data Payload:**
 *    ```cpp
 *    class DataRspPacket : public BaseRspPacket {
 *        uint8_t data[64];  // Cache line data
 *    };
 *    ```
 *
 * 3. **Add Transaction Type:**
 *    ```cpp
 *    enum ReqType { READ, WRITE, PREFETCH };
 *    class TypedReqPacket : public BaseReqPacket {
 *        ReqType type;
 *    };
 *    ```
 *
 * **Design Patterns:**
 *
 * 1. **Visitor Pattern:**
 *    - Packet type determines handler via visit()
 *    - Simulator type checked via dynamic_cast
 *    - Type-safe dispatching at runtime
 *
 * 2. **Double Dispatch:**
 *    - First dispatch: packet->visit(simulator)
 *    - Second dispatch: simulator->handler(packet)
 *    - Ensures correct handler called
 *
 * 3. **Request-Response Correlation:**
 *    - Request and response share same req_id
 *    - Enables out-of-order completion
 *    - Outstanding request tracking
 *
 * 4. **Object Pooling:**
 *    - RecycleContainer manages packet pool
 *    - renew() reinitializes instead of new
 *    - recycle() returns to pool instead of delete
 *
 * **Performance Considerations:**
 *
 * | Aspect              | Implementation                              | Performance Impact           |
 * |---------------------|---------------------------------------------|------------------------------|
 * | Packet allocation   | RecycleContainer pooling                    | Fast: No malloc overhead     |
 * | Type dispatching    | dynamic_cast in visit()                     | Moderate: RTTI lookup        |
 * | Handler calls       | Direct function call after cast             | Fast: No virtual overhead    |
 * | Memory reuse        | Pooled packets recycled                     | Excellent: Low fragmentation |
 *
 * **Best Practices:**
 *
 * 1. Always define renew() for custom packet types
 * 2. Call parent class renew() in derived renew()
 * 3. Only dispatch to simulators that have matching handler()
 * 4. Recycle packets after processing
 * 5. Use req_id for request-response correlation
 * 6. Keep packet data minimal for cache efficiency
 *
 * @see CPUCore For packet generation and response handling
 * @see CrossBar For packet forwarding with type dispatch
 * @see Memory For request processing and response generation
 * @see SimPacket For framework base class
 * @see RecycleContainer For packet memory management
 */

#include "BasePacket.hh"

#include "hw/CPUCore.hh"
#include "hw/CrossBar.hh"
#include "hw/Memory.hh"

namespace test_port {

/**
 * @brief Module-level visitor (unused in testSimPort).
 *
 * This visitor method would be called if packets were sent to SimModule
 * components (sub-components within a SimBase). In the testSimPort example,
 * packets are only sent between SimBase objects, so this method is empty.
 *
 * @param when Tick when packet was sent
 * @param module Target SimModule (sub-component)
 *
 * **When to Use:**
 * If you have hierarchical designs with SimModule sub-components:
 * ```cpp
 * void MyPacket::visit(Tick when, SimModule& module) {
 *     if (auto submodule = dynamic_cast<MySubModule*>(&module)) {
 *         submodule->handler(this);
 *     }
 * }
 * ```
 */
void BasePacket::visit(acalsim::Tick when, acalsim::SimModule& module) {}

/**
 * @brief Request packet visitor - routes to CrossBar or Memory handler.
 *
 * This method implements the visitor pattern for BaseReqPacket. It uses
 * dynamic_cast to determine the target simulator type and calls the
 * appropriate handler method.
 *
 * @param when Tick when packet arrived at simulator
 * @param simulator Target simulator receiving this request packet
 *
 * **Routing Logic:**
 * - If simulator is CrossBar → Call CrossBar::handler(BaseReqPacket*)
 * - If simulator is Memory → Call Memory::handler(BaseReqPacket*)
 * - Otherwise → Packet ignored (no matching handler)
 *
 * **Typical Flow:**
 * ```
 * CPU generates request:
 *   cpu->m_port->push(req);
 *
 * Framework transfers to Bus (Phase 2):
 *   bus->s_port receives packet
 *
 * Bus processes packet (Phase 1, next cycle):
 *   bus->accept(tick, req);
 *     └─► req->visit(tick, *bus);  // ◄─── This method called
 *          └─► xbar->handler(req);  // CrossBar::handler(BaseReqPacket*)
 *
 * Bus forwards to Memory:
 *   bus->m_port_to_mem->push(req);
 *
 * Memory processes packet:
 *   mem->accept(tick, req);
 *     └─► req->visit(tick, *mem);  // ◄─── This method called again
 *          └─► mem->handler(req);   // Memory::handler(BaseReqPacket*)
 * ```
 *
 * **Type Safety:**
 * - dynamic_cast returns nullptr if wrong type
 * - Only calls handler if cast succeeds
 * - Prevents calling handler on wrong simulator type
 *
 * @note CPUCore does not have handler(BaseReqPacket*), so requests never route to CPU
 */
void BaseReqPacket::visit(acalsim::Tick when, acalsim::SimBase& simulator) {
	if (auto xbar = dynamic_cast<CrossBar*>(&simulator)) {
		xbar->handler(this);
	} else if (auto mem = dynamic_cast<Memory*>(&simulator)) {
		mem->handler(this);
	}
}

/**
 * @brief Response packet visitor - routes to CPUCore or CrossBar handler.
 *
 * This method implements the visitor pattern for BaseRspPacket. It uses
 * dynamic_cast to determine the target simulator type and calls the
 * appropriate handler method.
 *
 * @param when Tick when packet arrived at simulator
 * @param simulator Target simulator receiving this response packet
 *
 * **Routing Logic:**
 * - If simulator is CPUCore → Call CPUCore::handler(BaseRspPacket*)
 * - If simulator is CrossBar → Call CrossBar::handler(BaseRspPacket*)
 * - Otherwise → Packet ignored (no matching handler)
 *
 * **Typical Flow:**
 * ```
 * Memory generates response:
 *   mem->m_port->push(rsp);
 *
 * Framework transfers to Bus (Phase 2):
 *   bus->s_port_from_mem receives packet
 *
 * Bus processes packet (Phase 1, next cycle):
 *   bus->accept(tick, rsp);
 *     └─► rsp->visit(tick, *bus);  // ◄─── This method called
 *          └─► xbar->handler(rsp);  // CrossBar::handler(BaseRspPacket*)
 *
 * Bus forwards to CPU:
 *   bus->m_port_to_cpu->push(rsp);
 *
 * CPU processes packet:
 *   cpu->accept(tick, rsp);
 *     └─► rsp->visit(tick, *cpu);  // ◄─── This method called again
 *          └─► cpu->handler(rsp);   // CPUCore::handler(BaseRspPacket*)
 * ```
 *
 * **Request-Response Matching:**
 * After routing to CPUCore::handler():
 * ```cpp
 * void CPUCore::handler(BaseRspPacket* rsp) {
 *     uint32_t req_id = rsp->getReqId();
 *     if (outstanding_req_queue.contains(req_id)) {
 *         outstanding_req_queue.remove(req_id);  // Match found!
 *         // Continue processing...
 *     }
 * }
 * ```
 *
 * **Type Safety:**
 * - dynamic_cast returns nullptr if wrong type
 * - Only calls handler if cast succeeds
 * - Prevents calling handler on wrong simulator type
 *
 * @note Memory does not have handler(BaseRspPacket*), so responses never route to Memory
 */
void BaseRspPacket::visit(acalsim::Tick when, acalsim::SimBase& simulator) {
	if (auto core = dynamic_cast<CPUCore*>(&simulator)) {
		core->handler(this);
	} else if (auto xbar = dynamic_cast<CrossBar*>(&simulator)) {
		xbar->handler(this);
	}
}

}  // namespace test_port
